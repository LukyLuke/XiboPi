/* soapStub.h
   Generated by gSOAP 2.8.61 for xibo.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_ns1	"urn:xmds"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20861
# error "GSOAP VERSION 20861 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__base64Binary;	/* xibo.h:140 */
struct ns1__RegisterDisplayResponse;	/* xibo.h:361 */
struct ns1__RegisterDisplay;	/* xibo.h:361 */
struct ns1__RequiredFilesResponse;	/* xibo.h:435 */
struct ns1__RequiredFiles;	/* xibo.h:435 */
struct ns1__GetFileResponse;	/* xibo.h:521 */
struct ns1__GetFile;	/* xibo.h:521 */
struct ns1__ScheduleResponse;	/* xibo.h:595 */
struct ns1__Schedule;	/* xibo.h:595 */
struct ns1__BlackListResponse;	/* xibo.h:678 */
struct ns1__BlackList;	/* xibo.h:678 */
struct ns1__SubmitLogResponse;	/* xibo.h:755 */
struct ns1__SubmitLog;	/* xibo.h:755 */
struct ns1__SubmitStatsResponse;	/* xibo.h:832 */
struct ns1__SubmitStats;	/* xibo.h:832 */
struct ns1__MediaInventoryResponse;	/* xibo.h:909 */
struct ns1__MediaInventory;	/* xibo.h:909 */
struct ns1__GetResourceResponse;	/* xibo.h:992 */
struct ns1__GetResource;	/* xibo.h:992 */
struct ns1__NotifyStatusResponse;	/* xibo.h:1069 */
struct ns1__NotifyStatus;	/* xibo.h:1069 */
struct ns1__SubmitScreenShotResponse;	/* xibo.h:1146 */
struct ns1__SubmitScreenShot;	/* xibo.h:1146 */

/* xibo.h:140 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (11)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XSD type 'xsd:string'
        char *id;
        /// Optional element 'type' of XSD type 'xsd:string'
        char *type;
        /// Optional element 'options' of XSD type 'xsd:string'
        char *options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options(), soap() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:361 */
#ifndef SOAP_TYPE_ns1__RegisterDisplayResponse
#define SOAP_TYPE_ns1__RegisterDisplayResponse (19)
/* complex XSD type 'ns1:RegisterDisplayResponse': */
struct SOAP_CMAC ns1__RegisterDisplayResponse {
      public:
        /** Required element 'ActivationMessage' of XSD type 'xsd:string' */
        std::string ActivationMessage;
      public:
        /** Return unique type id SOAP_TYPE_ns1__RegisterDisplayResponse */
        long soap_type() const { return SOAP_TYPE_ns1__RegisterDisplayResponse; }
        /** Constructor with member initializations */
        ns1__RegisterDisplayResponse() : ActivationMessage() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__RegisterDisplayResponse * SOAP_FMAC2 soap_instantiate_ns1__RegisterDisplayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:361 */
#ifndef SOAP_TYPE_ns1__RegisterDisplay
#define SOAP_TYPE_ns1__RegisterDisplay (20)
/* complex XSD type 'ns1:RegisterDisplay': */
struct SOAP_CMAC ns1__RegisterDisplay {
      public:
        /** Required element 'serverKey' of XSD type 'xsd:string' */
        std::string serverKey;
        /** Required element 'hardwareKey' of XSD type 'xsd:string' */
        std::string hardwareKey;
        /** Required element 'displayName' of XSD type 'xsd:string' */
        std::string displayName;
        /** Required element 'clientType' of XSD type 'xsd:string' */
        std::string clientType;
        /** Required element 'clientVersion' of XSD type 'xsd:string' */
        std::string clientVersion;
        /** Required element 'clientCode' of XSD type 'xsd:int' */
        int clientCode;
        /** Required element 'operatingSystem' of XSD type 'xsd:string' */
        std::string operatingSystem;
        /** Required element 'macAddress' of XSD type 'xsd:string' */
        std::string macAddress;
        /** Required element 'xmrChannel' of XSD type 'xsd:string' */
        std::string xmrChannel;
        /** Required element 'xmrPubKey' of XSD type 'xsd:string' */
        std::string xmrPubKey;
      public:
        /** Return unique type id SOAP_TYPE_ns1__RegisterDisplay */
        long soap_type() const { return SOAP_TYPE_ns1__RegisterDisplay; }
        /** Constructor with member initializations */
        ns1__RegisterDisplay() : serverKey(), hardwareKey(), displayName(), clientType(), clientVersion(), clientCode(), operatingSystem(), macAddress(), xmrChannel(), xmrPubKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__RegisterDisplay * SOAP_FMAC2 soap_instantiate_ns1__RegisterDisplay(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:435 */
#ifndef SOAP_TYPE_ns1__RequiredFilesResponse
#define SOAP_TYPE_ns1__RequiredFilesResponse (22)
/* complex XSD type 'ns1:RequiredFilesResponse': */
struct SOAP_CMAC ns1__RequiredFilesResponse {
      public:
        /** Required element 'RequiredFilesXml' of XSD type 'xsd:string' */
        std::string RequiredFilesXml;
      public:
        /** Return unique type id SOAP_TYPE_ns1__RequiredFilesResponse */
        long soap_type() const { return SOAP_TYPE_ns1__RequiredFilesResponse; }
        /** Constructor with member initializations */
        ns1__RequiredFilesResponse() : RequiredFilesXml() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__RequiredFilesResponse * SOAP_FMAC2 soap_instantiate_ns1__RequiredFilesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:435 */
#ifndef SOAP_TYPE_ns1__RequiredFiles
#define SOAP_TYPE_ns1__RequiredFiles (23)
/* complex XSD type 'ns1:RequiredFiles': */
struct SOAP_CMAC ns1__RequiredFiles {
      public:
        /** Required element 'serverKey' of XSD type 'xsd:string' */
        std::string serverKey;
        /** Required element 'hardwareKey' of XSD type 'xsd:string' */
        std::string hardwareKey;
      public:
        /** Return unique type id SOAP_TYPE_ns1__RequiredFiles */
        long soap_type() const { return SOAP_TYPE_ns1__RequiredFiles; }
        /** Constructor with member initializations */
        ns1__RequiredFiles() : serverKey(), hardwareKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__RequiredFiles * SOAP_FMAC2 soap_instantiate_ns1__RequiredFiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:521 */
#ifndef SOAP_TYPE_ns1__GetFileResponse
#define SOAP_TYPE_ns1__GetFileResponse (27)
/* complex XSD type 'ns1:GetFileResponse': */
struct SOAP_CMAC ns1__GetFileResponse {
      public:
        /** Required element 'file' of XSD type 'xsd:base64Binary' */
        xsd__base64Binary file;
      public:
        /** Return unique type id SOAP_TYPE_ns1__GetFileResponse */
        long soap_type() const { return SOAP_TYPE_ns1__GetFileResponse; }
        /** Constructor with member initializations */
        ns1__GetFileResponse() : file() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__GetFileResponse * SOAP_FMAC2 soap_instantiate_ns1__GetFileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:521 */
#ifndef SOAP_TYPE_ns1__GetFile
#define SOAP_TYPE_ns1__GetFile (28)
/* complex XSD type 'ns1:GetFile': */
struct SOAP_CMAC ns1__GetFile {
      public:
        /** Required element 'serverKey' of XSD type 'xsd:string' */
        std::string serverKey;
        /** Required element 'hardwareKey' of XSD type 'xsd:string' */
        std::string hardwareKey;
        /** Required element 'fileId' of XSD type 'xsd:int' */
        int fileId;
        /** Required element 'fileType' of XSD type 'xsd:string' */
        std::string fileType;
        /** Required element 'chunkOffset' of XSD type 'xsd:double' */
        double chunkOffset;
        /** Required element 'chuckSize' of XSD type 'xsd:double' */
        double chuckSize;
      public:
        /** Return unique type id SOAP_TYPE_ns1__GetFile */
        long soap_type() const { return SOAP_TYPE_ns1__GetFile; }
        /** Constructor with member initializations */
        ns1__GetFile() : serverKey(), hardwareKey(), fileId(), fileType(), chunkOffset(), chuckSize() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__GetFile * SOAP_FMAC2 soap_instantiate_ns1__GetFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:595 */
#ifndef SOAP_TYPE_ns1__ScheduleResponse
#define SOAP_TYPE_ns1__ScheduleResponse (30)
/* complex XSD type 'ns1:ScheduleResponse': */
struct SOAP_CMAC ns1__ScheduleResponse {
      public:
        /** Required element 'ScheduleXml' of XSD type 'xsd:string' */
        std::string ScheduleXml;
      public:
        /** Return unique type id SOAP_TYPE_ns1__ScheduleResponse */
        long soap_type() const { return SOAP_TYPE_ns1__ScheduleResponse; }
        /** Constructor with member initializations */
        ns1__ScheduleResponse() : ScheduleXml() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__ScheduleResponse * SOAP_FMAC2 soap_instantiate_ns1__ScheduleResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:595 */
#ifndef SOAP_TYPE_ns1__Schedule
#define SOAP_TYPE_ns1__Schedule (31)
/* complex XSD type 'ns1:Schedule': */
struct SOAP_CMAC ns1__Schedule {
      public:
        /** Required element 'serverKey' of XSD type 'xsd:string' */
        std::string serverKey;
        /** Required element 'hardwareKey' of XSD type 'xsd:string' */
        std::string hardwareKey;
      public:
        /** Return unique type id SOAP_TYPE_ns1__Schedule */
        long soap_type() const { return SOAP_TYPE_ns1__Schedule; }
        /** Constructor with member initializations */
        ns1__Schedule() : serverKey(), hardwareKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__Schedule * SOAP_FMAC2 soap_instantiate_ns1__Schedule(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:678 */
#ifndef SOAP_TYPE_ns1__BlackListResponse
#define SOAP_TYPE_ns1__BlackListResponse (35)
/* complex XSD type 'ns1:BlackListResponse': */
struct SOAP_CMAC ns1__BlackListResponse {
      public:
        /** Required element 'success' of XSD type 'xsd:boolean' */
        bool success;
      public:
        /** Return unique type id SOAP_TYPE_ns1__BlackListResponse */
        long soap_type() const { return SOAP_TYPE_ns1__BlackListResponse; }
        /** Constructor with member initializations */
        ns1__BlackListResponse() : success() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__BlackListResponse * SOAP_FMAC2 soap_instantiate_ns1__BlackListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:678 */
#ifndef SOAP_TYPE_ns1__BlackList
#define SOAP_TYPE_ns1__BlackList (36)
/* complex XSD type 'ns1:BlackList': */
struct SOAP_CMAC ns1__BlackList {
      public:
        /** Required element 'serverKey' of XSD type 'xsd:string' */
        std::string serverKey;
        /** Required element 'hardwareKey' of XSD type 'xsd:string' */
        std::string hardwareKey;
        /** Required element 'mediaId' of XSD type 'xsd:int' */
        int mediaId;
        /** Required element 'type' of XSD type 'xsd:string' */
        std::string type;
        /** Required element 'reason' of XSD type 'xsd:string' */
        std::string reason;
      public:
        /** Return unique type id SOAP_TYPE_ns1__BlackList */
        long soap_type() const { return SOAP_TYPE_ns1__BlackList; }
        /** Constructor with member initializations */
        ns1__BlackList() : serverKey(), hardwareKey(), mediaId(), type(), reason() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__BlackList * SOAP_FMAC2 soap_instantiate_ns1__BlackList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:755 */
#ifndef SOAP_TYPE_ns1__SubmitLogResponse
#define SOAP_TYPE_ns1__SubmitLogResponse (38)
/* complex XSD type 'ns1:SubmitLogResponse': */
struct SOAP_CMAC ns1__SubmitLogResponse {
      public:
        /** Required element 'success' of XSD type 'xsd:boolean' */
        bool success;
      public:
        /** Return unique type id SOAP_TYPE_ns1__SubmitLogResponse */
        long soap_type() const { return SOAP_TYPE_ns1__SubmitLogResponse; }
        /** Constructor with member initializations */
        ns1__SubmitLogResponse() : success() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__SubmitLogResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitLogResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:755 */
#ifndef SOAP_TYPE_ns1__SubmitLog
#define SOAP_TYPE_ns1__SubmitLog (39)
/* complex XSD type 'ns1:SubmitLog': */
struct SOAP_CMAC ns1__SubmitLog {
      public:
        /** Required element 'serverKey' of XSD type 'xsd:string' */
        std::string serverKey;
        /** Required element 'hardwareKey' of XSD type 'xsd:string' */
        std::string hardwareKey;
        /** Required element 'logXml' of XSD type 'xsd:string' */
        std::string logXml;
      public:
        /** Return unique type id SOAP_TYPE_ns1__SubmitLog */
        long soap_type() const { return SOAP_TYPE_ns1__SubmitLog; }
        /** Constructor with member initializations */
        ns1__SubmitLog() : serverKey(), hardwareKey(), logXml() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__SubmitLog * SOAP_FMAC2 soap_instantiate_ns1__SubmitLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:832 */
#ifndef SOAP_TYPE_ns1__SubmitStatsResponse
#define SOAP_TYPE_ns1__SubmitStatsResponse (41)
/* complex XSD type 'ns1:SubmitStatsResponse': */
struct SOAP_CMAC ns1__SubmitStatsResponse {
      public:
        /** Required element 'success' of XSD type 'xsd:boolean' */
        bool success;
      public:
        /** Return unique type id SOAP_TYPE_ns1__SubmitStatsResponse */
        long soap_type() const { return SOAP_TYPE_ns1__SubmitStatsResponse; }
        /** Constructor with member initializations */
        ns1__SubmitStatsResponse() : success() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__SubmitStatsResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitStatsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:832 */
#ifndef SOAP_TYPE_ns1__SubmitStats
#define SOAP_TYPE_ns1__SubmitStats (42)
/* complex XSD type 'ns1:SubmitStats': */
struct SOAP_CMAC ns1__SubmitStats {
      public:
        /** Required element 'serverKey' of XSD type 'xsd:string' */
        std::string serverKey;
        /** Required element 'hardwareKey' of XSD type 'xsd:string' */
        std::string hardwareKey;
        /** Required element 'statXml' of XSD type 'xsd:string' */
        std::string statXml;
      public:
        /** Return unique type id SOAP_TYPE_ns1__SubmitStats */
        long soap_type() const { return SOAP_TYPE_ns1__SubmitStats; }
        /** Constructor with member initializations */
        ns1__SubmitStats() : serverKey(), hardwareKey(), statXml() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__SubmitStats * SOAP_FMAC2 soap_instantiate_ns1__SubmitStats(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:909 */
#ifndef SOAP_TYPE_ns1__MediaInventoryResponse
#define SOAP_TYPE_ns1__MediaInventoryResponse (44)
/* complex XSD type 'ns1:MediaInventoryResponse': */
struct SOAP_CMAC ns1__MediaInventoryResponse {
      public:
        /** Required element 'success' of XSD type 'xsd:boolean' */
        bool success;
      public:
        /** Return unique type id SOAP_TYPE_ns1__MediaInventoryResponse */
        long soap_type() const { return SOAP_TYPE_ns1__MediaInventoryResponse; }
        /** Constructor with member initializations */
        ns1__MediaInventoryResponse() : success() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__MediaInventoryResponse * SOAP_FMAC2 soap_instantiate_ns1__MediaInventoryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:909 */
#ifndef SOAP_TYPE_ns1__MediaInventory
#define SOAP_TYPE_ns1__MediaInventory (45)
/* complex XSD type 'ns1:MediaInventory': */
struct SOAP_CMAC ns1__MediaInventory {
      public:
        /** Required element 'serverKey' of XSD type 'xsd:string' */
        std::string serverKey;
        /** Required element 'hardwareKey' of XSD type 'xsd:string' */
        std::string hardwareKey;
        /** Required element 'mediaInventory' of XSD type 'xsd:string' */
        std::string mediaInventory;
      public:
        /** Return unique type id SOAP_TYPE_ns1__MediaInventory */
        long soap_type() const { return SOAP_TYPE_ns1__MediaInventory; }
        /** Constructor with member initializations */
        ns1__MediaInventory() : serverKey(), hardwareKey(), mediaInventory() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__MediaInventory * SOAP_FMAC2 soap_instantiate_ns1__MediaInventory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:992 */
#ifndef SOAP_TYPE_ns1__GetResourceResponse
#define SOAP_TYPE_ns1__GetResourceResponse (47)
/* complex XSD type 'ns1:GetResourceResponse': */
struct SOAP_CMAC ns1__GetResourceResponse {
      public:
        /** Required element 'resource' of XSD type 'xsd:string' */
        std::string resource;
      public:
        /** Return unique type id SOAP_TYPE_ns1__GetResourceResponse */
        long soap_type() const { return SOAP_TYPE_ns1__GetResourceResponse; }
        /** Constructor with member initializations */
        ns1__GetResourceResponse() : resource() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__GetResourceResponse * SOAP_FMAC2 soap_instantiate_ns1__GetResourceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:992 */
#ifndef SOAP_TYPE_ns1__GetResource
#define SOAP_TYPE_ns1__GetResource (48)
/* complex XSD type 'ns1:GetResource': */
struct SOAP_CMAC ns1__GetResource {
      public:
        /** Required element 'serverKey' of XSD type 'xsd:string' */
        std::string serverKey;
        /** Required element 'hardwareKey' of XSD type 'xsd:string' */
        std::string hardwareKey;
        /** Required element 'layoutId' of XSD type 'xsd:int' */
        int layoutId;
        /** Required element 'regionId' of XSD type 'xsd:string' */
        std::string regionId;
        /** Required element 'mediaId' of XSD type 'xsd:string' */
        std::string mediaId;
      public:
        /** Return unique type id SOAP_TYPE_ns1__GetResource */
        long soap_type() const { return SOAP_TYPE_ns1__GetResource; }
        /** Constructor with member initializations */
        ns1__GetResource() : serverKey(), hardwareKey(), layoutId(), regionId(), mediaId() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__GetResource * SOAP_FMAC2 soap_instantiate_ns1__GetResource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:1069 */
#ifndef SOAP_TYPE_ns1__NotifyStatusResponse
#define SOAP_TYPE_ns1__NotifyStatusResponse (50)
/* complex XSD type 'ns1:NotifyStatusResponse': */
struct SOAP_CMAC ns1__NotifyStatusResponse {
      public:
        /** Required element 'success' of XSD type 'xsd:boolean' */
        bool success;
      public:
        /** Return unique type id SOAP_TYPE_ns1__NotifyStatusResponse */
        long soap_type() const { return SOAP_TYPE_ns1__NotifyStatusResponse; }
        /** Constructor with member initializations */
        ns1__NotifyStatusResponse() : success() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__NotifyStatusResponse * SOAP_FMAC2 soap_instantiate_ns1__NotifyStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:1069 */
#ifndef SOAP_TYPE_ns1__NotifyStatus
#define SOAP_TYPE_ns1__NotifyStatus (51)
/* complex XSD type 'ns1:NotifyStatus': */
struct SOAP_CMAC ns1__NotifyStatus {
      public:
        /** Required element 'serverKey' of XSD type 'xsd:string' */
        std::string serverKey;
        /** Required element 'hardwareKey' of XSD type 'xsd:string' */
        std::string hardwareKey;
        /** Required element 'status' of XSD type 'xsd:string' */
        std::string status;
      public:
        /** Return unique type id SOAP_TYPE_ns1__NotifyStatus */
        long soap_type() const { return SOAP_TYPE_ns1__NotifyStatus; }
        /** Constructor with member initializations */
        ns1__NotifyStatus() : serverKey(), hardwareKey(), status() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__NotifyStatus * SOAP_FMAC2 soap_instantiate_ns1__NotifyStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:1146 */
#ifndef SOAP_TYPE_ns1__SubmitScreenShotResponse
#define SOAP_TYPE_ns1__SubmitScreenShotResponse (53)
/* complex XSD type 'ns1:SubmitScreenShotResponse': */
struct SOAP_CMAC ns1__SubmitScreenShotResponse {
      public:
        /** Required element 'success' of XSD type 'xsd:boolean' */
        bool success;
      public:
        /** Return unique type id SOAP_TYPE_ns1__SubmitScreenShotResponse */
        long soap_type() const { return SOAP_TYPE_ns1__SubmitScreenShotResponse; }
        /** Constructor with member initializations */
        ns1__SubmitScreenShotResponse() : success() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__SubmitScreenShotResponse * SOAP_FMAC2 soap_instantiate_ns1__SubmitScreenShotResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:1146 */
#ifndef SOAP_TYPE_ns1__SubmitScreenShot
#define SOAP_TYPE_ns1__SubmitScreenShot (54)
/* complex XSD type 'ns1:SubmitScreenShot': */
struct SOAP_CMAC ns1__SubmitScreenShot {
      public:
        /** Required element 'serverKey' of XSD type 'xsd:string' */
        std::string serverKey;
        /** Required element 'hardwareKey' of XSD type 'xsd:string' */
        std::string hardwareKey;
        /** Required element 'screenShot' of XSD type 'xsd:base64Binary' */
        xsd__base64Binary screenShot;
      public:
        /** Return unique type id SOAP_TYPE_ns1__SubmitScreenShot */
        long soap_type() const { return SOAP_TYPE_ns1__SubmitScreenShot; }
        /** Constructor with member initializations */
        ns1__SubmitScreenShot() : serverKey(), hardwareKey(), screenShot() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__SubmitScreenShot * SOAP_FMAC2 soap_instantiate_ns1__SubmitScreenShot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xibo.h:1207 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (55)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* xibo.h:1207 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (56)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* xibo.h:1207 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (58)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* xibo.h:1207 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (61)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* xibo.h:1207 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (62)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (24)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (13)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (12)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (32)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (16)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (11)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (62)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (61)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (58)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (56)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (55)
#endif

/* struct ns1__SubmitScreenShot has binding name 'ns1__SubmitScreenShot' for type 'ns1:SubmitScreenShot' */
#ifndef SOAP_TYPE_ns1__SubmitScreenShot
#define SOAP_TYPE_ns1__SubmitScreenShot (54)
#endif

/* struct ns1__SubmitScreenShotResponse has binding name 'ns1__SubmitScreenShotResponse' for type 'ns1:SubmitScreenShotResponse' */
#ifndef SOAP_TYPE_ns1__SubmitScreenShotResponse
#define SOAP_TYPE_ns1__SubmitScreenShotResponse (53)
#endif

/* struct ns1__NotifyStatus has binding name 'ns1__NotifyStatus' for type 'ns1:NotifyStatus' */
#ifndef SOAP_TYPE_ns1__NotifyStatus
#define SOAP_TYPE_ns1__NotifyStatus (51)
#endif

/* struct ns1__NotifyStatusResponse has binding name 'ns1__NotifyStatusResponse' for type 'ns1:NotifyStatusResponse' */
#ifndef SOAP_TYPE_ns1__NotifyStatusResponse
#define SOAP_TYPE_ns1__NotifyStatusResponse (50)
#endif

/* struct ns1__GetResource has binding name 'ns1__GetResource' for type 'ns1:GetResource' */
#ifndef SOAP_TYPE_ns1__GetResource
#define SOAP_TYPE_ns1__GetResource (48)
#endif

/* struct ns1__GetResourceResponse has binding name 'ns1__GetResourceResponse' for type 'ns1:GetResourceResponse' */
#ifndef SOAP_TYPE_ns1__GetResourceResponse
#define SOAP_TYPE_ns1__GetResourceResponse (47)
#endif

/* struct ns1__MediaInventory has binding name 'ns1__MediaInventory' for type 'ns1:MediaInventory' */
#ifndef SOAP_TYPE_ns1__MediaInventory
#define SOAP_TYPE_ns1__MediaInventory (45)
#endif

/* struct ns1__MediaInventoryResponse has binding name 'ns1__MediaInventoryResponse' for type 'ns1:MediaInventoryResponse' */
#ifndef SOAP_TYPE_ns1__MediaInventoryResponse
#define SOAP_TYPE_ns1__MediaInventoryResponse (44)
#endif

/* struct ns1__SubmitStats has binding name 'ns1__SubmitStats' for type 'ns1:SubmitStats' */
#ifndef SOAP_TYPE_ns1__SubmitStats
#define SOAP_TYPE_ns1__SubmitStats (42)
#endif

/* struct ns1__SubmitStatsResponse has binding name 'ns1__SubmitStatsResponse' for type 'ns1:SubmitStatsResponse' */
#ifndef SOAP_TYPE_ns1__SubmitStatsResponse
#define SOAP_TYPE_ns1__SubmitStatsResponse (41)
#endif

/* struct ns1__SubmitLog has binding name 'ns1__SubmitLog' for type 'ns1:SubmitLog' */
#ifndef SOAP_TYPE_ns1__SubmitLog
#define SOAP_TYPE_ns1__SubmitLog (39)
#endif

/* struct ns1__SubmitLogResponse has binding name 'ns1__SubmitLogResponse' for type 'ns1:SubmitLogResponse' */
#ifndef SOAP_TYPE_ns1__SubmitLogResponse
#define SOAP_TYPE_ns1__SubmitLogResponse (38)
#endif

/* struct ns1__BlackList has binding name 'ns1__BlackList' for type 'ns1:BlackList' */
#ifndef SOAP_TYPE_ns1__BlackList
#define SOAP_TYPE_ns1__BlackList (36)
#endif

/* struct ns1__BlackListResponse has binding name 'ns1__BlackListResponse' for type 'ns1:BlackListResponse' */
#ifndef SOAP_TYPE_ns1__BlackListResponse
#define SOAP_TYPE_ns1__BlackListResponse (35)
#endif

/* struct ns1__Schedule has binding name 'ns1__Schedule' for type 'ns1:Schedule' */
#ifndef SOAP_TYPE_ns1__Schedule
#define SOAP_TYPE_ns1__Schedule (31)
#endif

/* struct ns1__ScheduleResponse has binding name 'ns1__ScheduleResponse' for type 'ns1:ScheduleResponse' */
#ifndef SOAP_TYPE_ns1__ScheduleResponse
#define SOAP_TYPE_ns1__ScheduleResponse (30)
#endif

/* struct ns1__GetFile has binding name 'ns1__GetFile' for type 'ns1:GetFile' */
#ifndef SOAP_TYPE_ns1__GetFile
#define SOAP_TYPE_ns1__GetFile (28)
#endif

/* struct ns1__GetFileResponse has binding name 'ns1__GetFileResponse' for type 'ns1:GetFileResponse' */
#ifndef SOAP_TYPE_ns1__GetFileResponse
#define SOAP_TYPE_ns1__GetFileResponse (27)
#endif

/* struct ns1__RequiredFiles has binding name 'ns1__RequiredFiles' for type 'ns1:RequiredFiles' */
#ifndef SOAP_TYPE_ns1__RequiredFiles
#define SOAP_TYPE_ns1__RequiredFiles (23)
#endif

/* struct ns1__RequiredFilesResponse has binding name 'ns1__RequiredFilesResponse' for type 'ns1:RequiredFilesResponse' */
#ifndef SOAP_TYPE_ns1__RequiredFilesResponse
#define SOAP_TYPE_ns1__RequiredFilesResponse (22)
#endif

/* struct ns1__RegisterDisplay has binding name 'ns1__RegisterDisplay' for type 'ns1:RegisterDisplay' */
#ifndef SOAP_TYPE_ns1__RegisterDisplay
#define SOAP_TYPE_ns1__RegisterDisplay (20)
#endif

/* struct ns1__RegisterDisplayResponse has binding name 'ns1__RegisterDisplayResponse' for type 'ns1:RegisterDisplayResponse' */
#ifndef SOAP_TYPE_ns1__RegisterDisplayResponse
#define SOAP_TYPE_ns1__RegisterDisplayResponse (19)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (64)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (63)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (57)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (14)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
