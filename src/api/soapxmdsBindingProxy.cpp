/* soapxmdsBindingProxy.cpp
   Generated by gSOAP 2.8.61 for xibo.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include "soapxmdsBindingProxy.h"

xmdsBindingProxy::xmdsBindingProxy()
{	this->soap = soap_new();
	this->soap_own = true;
	xmdsBindingProxy_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

xmdsBindingProxy::xmdsBindingProxy(const xmdsBindingProxy& rhs)
{	this->soap = rhs.soap;
	this->soap_own = false;
	this->soap_endpoint = rhs.soap_endpoint;
}

xmdsBindingProxy::xmdsBindingProxy(struct soap *_soap)
{	this->soap = _soap;
	this->soap_own = false;
	xmdsBindingProxy_init(_soap->imode, _soap->omode);
}

xmdsBindingProxy::xmdsBindingProxy(const char *endpoint)
{	this->soap = soap_new();
	this->soap_own = true;
	xmdsBindingProxy_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
	soap_endpoint = endpoint;
}

xmdsBindingProxy::xmdsBindingProxy(soap_mode iomode)
{	this->soap = soap_new();
	this->soap_own = true;
	xmdsBindingProxy_init(iomode, iomode);
}

xmdsBindingProxy::xmdsBindingProxy(const char *endpoint, soap_mode iomode)
{	this->soap = soap_new();
	this->soap_own = true;
	xmdsBindingProxy_init(iomode, iomode);
	soap_endpoint = endpoint;
}

xmdsBindingProxy::xmdsBindingProxy(soap_mode imode, soap_mode omode)
{	this->soap = soap_new();
	this->soap_own = true;
	xmdsBindingProxy_init(imode, omode);
}

xmdsBindingProxy::~xmdsBindingProxy()
{	if (this->soap_own)
		soap_free(this->soap);
}

void xmdsBindingProxy::xmdsBindingProxy_init(soap_mode imode, soap_mode omode)
{	soap_imode(this->soap, imode);
	soap_omode(this->soap, omode);
	soap_endpoint = NULL;
	static const struct Namespace namespaces[] = {
        {"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL},
        {"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL},
        {"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL},
        {"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL},
        {"ns1", "urn:xmds", NULL, NULL},
        {NULL, NULL, NULL, NULL}
    };
	soap_set_namespaces(this->soap, namespaces);
}

xmdsBindingProxy *xmdsBindingProxy::copy()
{	xmdsBindingProxy *dup = SOAP_NEW_UNMANAGED(xmdsBindingProxy);
	if (dup)
		soap_copy_context(dup->soap, this->soap);
	return dup;
}

xmdsBindingProxy& xmdsBindingProxy::operator=(const xmdsBindingProxy& rhs)
{	if (this->soap != rhs.soap)
	{	if (this->soap_own)
			soap_free(this->soap);
		this->soap = rhs.soap;
		this->soap_own = false;
		this->soap_endpoint = rhs.soap_endpoint;
	}
	return *this;
}

void xmdsBindingProxy::destroy()
{	soap_destroy(this->soap);
	soap_end(this->soap);
}

void xmdsBindingProxy::reset()
{	this->destroy();
	soap_done(this->soap);
	soap_initialize(this->soap);
	xmdsBindingProxy_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

void xmdsBindingProxy::soap_noheader()
{	this->soap->header = NULL;
}

::SOAP_ENV__Header *xmdsBindingProxy::soap_header()
{	return this->soap->header;
}

::SOAP_ENV__Fault *xmdsBindingProxy::soap_fault()
{	return this->soap->fault;
}

const char *xmdsBindingProxy::soap_fault_string()
{	return *soap_faultstring(this->soap);
}

const char *xmdsBindingProxy::soap_fault_detail()
{	return *soap_faultdetail(this->soap);
}

int xmdsBindingProxy::soap_close_socket()
{	return soap_closesock(this->soap);
}

int xmdsBindingProxy::soap_force_close_socket()
{	return soap_force_closesock(this->soap);
}

void xmdsBindingProxy::soap_print_fault(FILE *fd)
{	::soap_print_fault(this->soap, fd);
}

#ifndef WITH_LEAN
#ifndef WITH_COMPAT
void xmdsBindingProxy::soap_stream_fault(std::ostream& os)
{	::soap_stream_fault(this->soap, os);
}
#endif

char *xmdsBindingProxy::soap_sprint_fault(char *buf, size_t len)
{	return ::soap_sprint_fault(this->soap, buf, len);
}
#endif

int xmdsBindingProxy::RegisterDisplay(const char *endpoint, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, const std::string& displayName, const std::string& clientType, const std::string& clientVersion, int clientCode, const std::string& operatingSystem, const std::string& macAddress, const std::string& xmrChannel, const std::string& xmrPubKey, std::string &ActivationMessage)
{	struct soap *soap = this->soap;
	struct ns1__RegisterDisplay soap_tmp_ns1__RegisterDisplay;
	struct ns1__RegisterDisplayResponse *soap_tmp_ns1__RegisterDisplayResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#RegisterDisplay";
	soap_tmp_ns1__RegisterDisplay.serverKey = serverKey;
	soap_tmp_ns1__RegisterDisplay.hardwareKey = hardwareKey;
	soap_tmp_ns1__RegisterDisplay.displayName = displayName;
	soap_tmp_ns1__RegisterDisplay.clientType = clientType;
	soap_tmp_ns1__RegisterDisplay.clientVersion = clientVersion;
	soap_tmp_ns1__RegisterDisplay.clientCode = clientCode;
	soap_tmp_ns1__RegisterDisplay.operatingSystem = operatingSystem;
	soap_tmp_ns1__RegisterDisplay.macAddress = macAddress;
	soap_tmp_ns1__RegisterDisplay.xmrChannel = xmrChannel;
	soap_tmp_ns1__RegisterDisplay.xmrPubKey = xmrPubKey;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__RegisterDisplay(soap, &soap_tmp_ns1__RegisterDisplay);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__RegisterDisplay(soap, &soap_tmp_ns1__RegisterDisplay, "ns1:RegisterDisplay", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__RegisterDisplay(soap, &soap_tmp_ns1__RegisterDisplay, "ns1:RegisterDisplay", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!static_cast<std::string*>(&ActivationMessage)) // NULL ref?
		return soap_closesock(soap);
	soap_default_std__string(soap, &ActivationMessage);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__RegisterDisplayResponse = soap_get_ns1__RegisterDisplayResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__RegisterDisplayResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	ActivationMessage = soap_tmp_ns1__RegisterDisplayResponse->ActivationMessage;
	return soap_closesock(soap);
}

int xmdsBindingProxy::RequiredFiles(const char *endpoint, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, std::string &RequiredFilesXml)
{	struct soap *soap = this->soap;
	struct ns1__RequiredFiles soap_tmp_ns1__RequiredFiles;
	struct ns1__RequiredFilesResponse *soap_tmp_ns1__RequiredFilesResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#RequiredFiles";
	soap_tmp_ns1__RequiredFiles.serverKey = serverKey;
	soap_tmp_ns1__RequiredFiles.hardwareKey = hardwareKey;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__RequiredFiles(soap, &soap_tmp_ns1__RequiredFiles);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__RequiredFiles(soap, &soap_tmp_ns1__RequiredFiles, "ns1:RequiredFiles", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__RequiredFiles(soap, &soap_tmp_ns1__RequiredFiles, "ns1:RequiredFiles", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!static_cast<std::string*>(&RequiredFilesXml)) // NULL ref?
		return soap_closesock(soap);
	soap_default_std__string(soap, &RequiredFilesXml);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__RequiredFilesResponse = soap_get_ns1__RequiredFilesResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__RequiredFilesResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	RequiredFilesXml = soap_tmp_ns1__RequiredFilesResponse->RequiredFilesXml;
	return soap_closesock(soap);
}

int xmdsBindingProxy::GetFile(const char *endpoint, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, int fileId, const std::string& fileType, double chunkOffset, double chuckSize, xsd__base64Binary &file)
{	struct soap *soap = this->soap;
	struct ns1__GetFile soap_tmp_ns1__GetFile;
	struct ns1__GetFileResponse *soap_tmp_ns1__GetFileResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#GetFile";
	soap_tmp_ns1__GetFile.serverKey = serverKey;
	soap_tmp_ns1__GetFile.hardwareKey = hardwareKey;
	soap_tmp_ns1__GetFile.fileId = fileId;
	soap_tmp_ns1__GetFile.fileType = fileType;
	soap_tmp_ns1__GetFile.chunkOffset = chunkOffset;
	soap_tmp_ns1__GetFile.chuckSize = chuckSize;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__GetFile(soap, &soap_tmp_ns1__GetFile);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__GetFile(soap, &soap_tmp_ns1__GetFile, "ns1:GetFile", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__GetFile(soap, &soap_tmp_ns1__GetFile, "ns1:GetFile", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!static_cast<xsd__base64Binary*>(&file)) // NULL ref?
		return soap_closesock(soap);
	file.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__GetFileResponse = soap_get_ns1__GetFileResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__GetFileResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	file = soap_tmp_ns1__GetFileResponse->file;
	return soap_closesock(soap);
}

int xmdsBindingProxy::Schedule(const char *endpoint, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, std::string &ScheduleXml)
{	struct soap *soap = this->soap;
	struct ns1__Schedule soap_tmp_ns1__Schedule;
	struct ns1__ScheduleResponse *soap_tmp_ns1__ScheduleResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#Schedule";
	soap_tmp_ns1__Schedule.serverKey = serverKey;
	soap_tmp_ns1__Schedule.hardwareKey = hardwareKey;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__Schedule(soap, &soap_tmp_ns1__Schedule);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__Schedule(soap, &soap_tmp_ns1__Schedule, "ns1:Schedule", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__Schedule(soap, &soap_tmp_ns1__Schedule, "ns1:Schedule", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!static_cast<std::string*>(&ScheduleXml)) // NULL ref?
		return soap_closesock(soap);
	soap_default_std__string(soap, &ScheduleXml);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__ScheduleResponse = soap_get_ns1__ScheduleResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__ScheduleResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	ScheduleXml = soap_tmp_ns1__ScheduleResponse->ScheduleXml;
	return soap_closesock(soap);
}

int xmdsBindingProxy::BlackList(const char *endpoint, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, int mediaId, const std::string& type, const std::string& reason, bool &success)
{	struct soap *soap = this->soap;
	struct ns1__BlackList soap_tmp_ns1__BlackList;
	struct ns1__BlackListResponse *soap_tmp_ns1__BlackListResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#BlackList";
	soap_tmp_ns1__BlackList.serverKey = serverKey;
	soap_tmp_ns1__BlackList.hardwareKey = hardwareKey;
	soap_tmp_ns1__BlackList.mediaId = mediaId;
	soap_tmp_ns1__BlackList.type = type;
	soap_tmp_ns1__BlackList.reason = reason;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__BlackList(soap, &soap_tmp_ns1__BlackList);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__BlackList(soap, &soap_tmp_ns1__BlackList, "ns1:BlackList", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__BlackList(soap, &soap_tmp_ns1__BlackList, "ns1:BlackList", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!static_cast<bool*>(&success)) // NULL ref?
		return soap_closesock(soap);
	soap_default_bool(soap, &success);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__BlackListResponse = soap_get_ns1__BlackListResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__BlackListResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	success = soap_tmp_ns1__BlackListResponse->success;
	return soap_closesock(soap);
}

int xmdsBindingProxy::SubmitLog(const char *endpoint, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, const std::string& logXml, bool &success)
{	struct soap *soap = this->soap;
	struct ns1__SubmitLog soap_tmp_ns1__SubmitLog;
	struct ns1__SubmitLogResponse *soap_tmp_ns1__SubmitLogResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#SubmitLog";
	soap_tmp_ns1__SubmitLog.serverKey = serverKey;
	soap_tmp_ns1__SubmitLog.hardwareKey = hardwareKey;
	soap_tmp_ns1__SubmitLog.logXml = logXml;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__SubmitLog(soap, &soap_tmp_ns1__SubmitLog);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__SubmitLog(soap, &soap_tmp_ns1__SubmitLog, "ns1:SubmitLog", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__SubmitLog(soap, &soap_tmp_ns1__SubmitLog, "ns1:SubmitLog", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!static_cast<bool*>(&success)) // NULL ref?
		return soap_closesock(soap);
	soap_default_bool(soap, &success);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__SubmitLogResponse = soap_get_ns1__SubmitLogResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__SubmitLogResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	success = soap_tmp_ns1__SubmitLogResponse->success;
	return soap_closesock(soap);
}

int xmdsBindingProxy::SubmitStats(const char *endpoint, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, const std::string& statXml, bool &success)
{	struct soap *soap = this->soap;
	struct ns1__SubmitStats soap_tmp_ns1__SubmitStats;
	struct ns1__SubmitStatsResponse *soap_tmp_ns1__SubmitStatsResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#SubmitLog";
	soap_tmp_ns1__SubmitStats.serverKey = serverKey;
	soap_tmp_ns1__SubmitStats.hardwareKey = hardwareKey;
	soap_tmp_ns1__SubmitStats.statXml = statXml;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__SubmitStats(soap, &soap_tmp_ns1__SubmitStats);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__SubmitStats(soap, &soap_tmp_ns1__SubmitStats, "ns1:SubmitStats", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__SubmitStats(soap, &soap_tmp_ns1__SubmitStats, "ns1:SubmitStats", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!static_cast<bool*>(&success)) // NULL ref?
		return soap_closesock(soap);
	soap_default_bool(soap, &success);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__SubmitStatsResponse = soap_get_ns1__SubmitStatsResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__SubmitStatsResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	success = soap_tmp_ns1__SubmitStatsResponse->success;
	return soap_closesock(soap);
}

int xmdsBindingProxy::MediaInventory(const char *endpoint, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, const std::string& mediaInventory, bool &success)
{	struct soap *soap = this->soap;
	struct ns1__MediaInventory soap_tmp_ns1__MediaInventory;
	struct ns1__MediaInventoryResponse *soap_tmp_ns1__MediaInventoryResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#MediaInventory";
	soap_tmp_ns1__MediaInventory.serverKey = serverKey;
	soap_tmp_ns1__MediaInventory.hardwareKey = hardwareKey;
	soap_tmp_ns1__MediaInventory.mediaInventory = mediaInventory;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__MediaInventory(soap, &soap_tmp_ns1__MediaInventory);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__MediaInventory(soap, &soap_tmp_ns1__MediaInventory, "ns1:MediaInventory", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__MediaInventory(soap, &soap_tmp_ns1__MediaInventory, "ns1:MediaInventory", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!static_cast<bool*>(&success)) // NULL ref?
		return soap_closesock(soap);
	soap_default_bool(soap, &success);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__MediaInventoryResponse = soap_get_ns1__MediaInventoryResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__MediaInventoryResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	success = soap_tmp_ns1__MediaInventoryResponse->success;
	return soap_closesock(soap);
}

int xmdsBindingProxy::GetResource(const char *endpoint, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, int layoutId, const std::string& regionId, const std::string& mediaId, std::string &resource)
{	struct soap *soap = this->soap;
	struct ns1__GetResource soap_tmp_ns1__GetResource;
	struct ns1__GetResourceResponse *soap_tmp_ns1__GetResourceResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#GetResource";
	soap_tmp_ns1__GetResource.serverKey = serverKey;
	soap_tmp_ns1__GetResource.hardwareKey = hardwareKey;
	soap_tmp_ns1__GetResource.layoutId = layoutId;
	soap_tmp_ns1__GetResource.regionId = regionId;
	soap_tmp_ns1__GetResource.mediaId = mediaId;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__GetResource(soap, &soap_tmp_ns1__GetResource);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__GetResource(soap, &soap_tmp_ns1__GetResource, "ns1:GetResource", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__GetResource(soap, &soap_tmp_ns1__GetResource, "ns1:GetResource", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!static_cast<std::string*>(&resource)) // NULL ref?
		return soap_closesock(soap);
	soap_default_std__string(soap, &resource);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__GetResourceResponse = soap_get_ns1__GetResourceResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__GetResourceResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	resource = soap_tmp_ns1__GetResourceResponse->resource;
	return soap_closesock(soap);
}

int xmdsBindingProxy::NotifyStatus(const char *endpoint, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, const std::string& status, bool &success)
{	struct soap *soap = this->soap;
	struct ns1__NotifyStatus soap_tmp_ns1__NotifyStatus;
	struct ns1__NotifyStatusResponse *soap_tmp_ns1__NotifyStatusResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#NotifyStatus";
	soap_tmp_ns1__NotifyStatus.serverKey = serverKey;
	soap_tmp_ns1__NotifyStatus.hardwareKey = hardwareKey;
	soap_tmp_ns1__NotifyStatus.status = status;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__NotifyStatus(soap, &soap_tmp_ns1__NotifyStatus);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__NotifyStatus(soap, &soap_tmp_ns1__NotifyStatus, "ns1:NotifyStatus", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__NotifyStatus(soap, &soap_tmp_ns1__NotifyStatus, "ns1:NotifyStatus", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!static_cast<bool*>(&success)) // NULL ref?
		return soap_closesock(soap);
	soap_default_bool(soap, &success);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__NotifyStatusResponse = soap_get_ns1__NotifyStatusResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__NotifyStatusResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	success = soap_tmp_ns1__NotifyStatusResponse->success;
	return soap_closesock(soap);
}

int xmdsBindingProxy::SubmitScreenShot(const char *endpoint, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, const xsd__base64Binary& screenShot, bool &success)
{	struct soap *soap = this->soap;
	struct ns1__SubmitScreenShot soap_tmp_ns1__SubmitScreenShot;
	struct ns1__SubmitScreenShotResponse *soap_tmp_ns1__SubmitScreenShotResponse;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#SubmitScreenShot";
	soap_tmp_ns1__SubmitScreenShot.serverKey = serverKey;
	soap_tmp_ns1__SubmitScreenShot.hardwareKey = hardwareKey;
	soap_tmp_ns1__SubmitScreenShot.screenShot = screenShot;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
	soap_serializeheader(soap);
	soap_serialize_ns1__SubmitScreenShot(soap, &soap_tmp_ns1__SubmitScreenShot);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__SubmitScreenShot(soap, &soap_tmp_ns1__SubmitScreenShot, "ns1:SubmitScreenShot", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__SubmitScreenShot(soap, &soap_tmp_ns1__SubmitScreenShot, "ns1:SubmitScreenShot", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!static_cast<bool*>(&success)) // NULL ref?
		return soap_closesock(soap);
	soap_default_bool(soap, &success);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__SubmitScreenShotResponse = soap_get_ns1__SubmitScreenShotResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__SubmitScreenShotResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	success = soap_tmp_ns1__SubmitScreenShotResponse->success;
	return soap_closesock(soap);
}
/* End of client proxy code */
