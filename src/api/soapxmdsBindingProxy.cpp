/* soapxmdsBindingProxy.cpp
   Generated by gSOAP 2.8.78 for xibo.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include "soapxmdsBindingProxy.h"

xmdsBindingProxy::xmdsBindingProxy()
{	this->soap = soap_new();
	this->soap_own = true;
	xmdsBindingProxy_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

xmdsBindingProxy::xmdsBindingProxy(const xmdsBindingProxy& rhs)
{	this->soap = rhs.soap;
	this->soap_own = false;
	this->soap_endpoint = rhs.soap_endpoint;
}

xmdsBindingProxy::xmdsBindingProxy(struct soap *_soap)
{	this->soap = _soap;
	this->soap_own = false;
	xmdsBindingProxy_init(_soap->imode, _soap->omode);
}

xmdsBindingProxy::xmdsBindingProxy(struct soap *_soap, const char *soap_endpoint_url)
{	this->soap = _soap;
	this->soap_own = false;
	xmdsBindingProxy_init(_soap->imode, _soap->omode);
	soap_endpoint = soap_endpoint_url;
}

xmdsBindingProxy::xmdsBindingProxy(const char *soap_endpoint_url)
{	this->soap = soap_new();
	this->soap_own = true;
	xmdsBindingProxy_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
	soap_endpoint = soap_endpoint_url;
}

xmdsBindingProxy::xmdsBindingProxy(soap_mode iomode)
{	this->soap = soap_new();
	this->soap_own = true;
	xmdsBindingProxy_init(iomode, iomode);
}

xmdsBindingProxy::xmdsBindingProxy(const char *soap_endpoint_url, soap_mode iomode)
{	this->soap = soap_new();
	this->soap_own = true;
	xmdsBindingProxy_init(iomode, iomode);
	soap_endpoint = soap_endpoint_url;
}

xmdsBindingProxy::xmdsBindingProxy(soap_mode imode, soap_mode omode)
{	this->soap = soap_new();
	this->soap_own = true;
	xmdsBindingProxy_init(imode, omode);
}

xmdsBindingProxy::~xmdsBindingProxy()
{	if (this->soap_own)
	{	this->destroy();
		soap_free(this->soap);
	}
}

void xmdsBindingProxy::xmdsBindingProxy_init(soap_mode imode, soap_mode omode)
{	soap_imode(this->soap, imode);
	soap_omode(this->soap, omode);
	soap_endpoint = NULL;
	static const struct Namespace namespaces[] = {
        { "SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL },
        { "SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL },
        { "xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL },
        { "xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL },
        { "ns1", "urn:xmds", NULL, NULL },
        { NULL, NULL, NULL, NULL}
    };
	soap_set_namespaces(this->soap, namespaces);
}

xmdsBindingProxy *xmdsBindingProxy::copy()
{	xmdsBindingProxy *dup = SOAP_NEW_UNMANAGED(xmdsBindingProxy);
	if (dup)
	{	soap_done(dup->soap);
		soap_copy_context(dup->soap, this->soap);
	}
	return dup;
}

xmdsBindingProxy& xmdsBindingProxy::operator=(const xmdsBindingProxy& rhs)
{	if (this->soap != rhs.soap)
	{	if (this->soap_own)
			soap_free(this->soap);
		this->soap = rhs.soap;
		this->soap_own = false;
		this->soap_endpoint = rhs.soap_endpoint;
	}
	return *this;
}

void xmdsBindingProxy::destroy()
{	soap_destroy(this->soap);
	soap_end(this->soap);
}

void xmdsBindingProxy::reset()
{	this->destroy();
	soap_done(this->soap);
	soap_initialize(this->soap);
	xmdsBindingProxy_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

void xmdsBindingProxy::soap_noheader()
{	this->soap->header = NULL;
}

::SOAP_ENV__Header *xmdsBindingProxy::soap_header()
{	return this->soap->header;
}

::SOAP_ENV__Fault *xmdsBindingProxy::soap_fault()
{	return this->soap->fault;
}

const char *xmdsBindingProxy::soap_fault_subcode()
{	return ::soap_fault_subcode(this->soap);
}

const char *xmdsBindingProxy::soap_fault_string()
{	return ::soap_fault_string(this->soap);
}

const char *xmdsBindingProxy::soap_fault_detail()
{	return ::soap_fault_detail(this->soap);
}

int xmdsBindingProxy::soap_close_socket()
{	return ::soap_closesock(this->soap);
}

int xmdsBindingProxy::soap_force_close_socket()
{	return ::soap_force_closesock(this->soap);
}

void xmdsBindingProxy::soap_print_fault(FILE *fd)
{	::soap_print_fault(this->soap, fd);
}

#ifndef WITH_LEAN
#ifndef WITH_COMPAT
void xmdsBindingProxy::soap_stream_fault(std::ostream& os)
{	::soap_stream_fault(this->soap, os);
}
#endif

char *xmdsBindingProxy::soap_sprint_fault(char *buf, size_t len)
{	return ::soap_sprint_fault(this->soap, buf, len);
}
#endif

int xmdsBindingProxy::send_RegisterDisplay(const char *soap_endpoint_url, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, const std::string& displayName, const std::string& clientType, const std::string& clientVersion, int clientCode, const std::string& operatingSystem, const std::string& macAddress, const std::string& xmrChannel, const std::string& xmrPubKey)
{
	struct ns1__RegisterDisplay soap_tmp_ns1__RegisterDisplay;
	if (soap_endpoint_url != NULL)
		soap_endpoint = soap_endpoint_url;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#RegisterDisplay";
	soap_tmp_ns1__RegisterDisplay.serverKey = serverKey;
	soap_tmp_ns1__RegisterDisplay.hardwareKey = hardwareKey;
	soap_tmp_ns1__RegisterDisplay.displayName = displayName;
	soap_tmp_ns1__RegisterDisplay.clientType = clientType;
	soap_tmp_ns1__RegisterDisplay.clientVersion = clientVersion;
	soap_tmp_ns1__RegisterDisplay.clientCode = clientCode;
	soap_tmp_ns1__RegisterDisplay.operatingSystem = operatingSystem;
	soap_tmp_ns1__RegisterDisplay.macAddress = macAddress;
	soap_tmp_ns1__RegisterDisplay.xmrChannel = xmrChannel;
	soap_tmp_ns1__RegisterDisplay.xmrPubKey = xmrPubKey;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/"; /* use SOAP encoding style */
	soap_serializeheader(soap);
	soap_serialize_ns1__RegisterDisplay(soap, &soap_tmp_ns1__RegisterDisplay);
	if (soap_begin_count(soap))
		return soap->error;
	if ((soap->mode & SOAP_IO_LENGTH))
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__RegisterDisplay(soap, &soap_tmp_ns1__RegisterDisplay, "ns1:RegisterDisplay", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__RegisterDisplay(soap, &soap_tmp_ns1__RegisterDisplay, "ns1:RegisterDisplay", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

int xmdsBindingProxy::recv_RegisterDisplay(std::string &ActivationMessage)
{
	struct ns1__RegisterDisplayResponse *soap_tmp_ns1__RegisterDisplayResponse;
	soap_default_std__string(soap, &ActivationMessage);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__RegisterDisplayResponse = soap_get_ns1__RegisterDisplayResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__RegisterDisplayResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	ActivationMessage = soap_tmp_ns1__RegisterDisplayResponse->ActivationMessage;
	return soap_closesock(soap);
}

int xmdsBindingProxy::send_RequiredFiles(const char *soap_endpoint_url, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey)
{
	struct ns1__RequiredFiles soap_tmp_ns1__RequiredFiles;
	if (soap_endpoint_url != NULL)
		soap_endpoint = soap_endpoint_url;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#RequiredFiles";
	soap_tmp_ns1__RequiredFiles.serverKey = serverKey;
	soap_tmp_ns1__RequiredFiles.hardwareKey = hardwareKey;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/"; /* use SOAP encoding style */
	soap_serializeheader(soap);
	soap_serialize_ns1__RequiredFiles(soap, &soap_tmp_ns1__RequiredFiles);
	if (soap_begin_count(soap))
		return soap->error;
	if ((soap->mode & SOAP_IO_LENGTH))
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__RequiredFiles(soap, &soap_tmp_ns1__RequiredFiles, "ns1:RequiredFiles", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__RequiredFiles(soap, &soap_tmp_ns1__RequiredFiles, "ns1:RequiredFiles", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

int xmdsBindingProxy::recv_RequiredFiles(std::string &RequiredFilesXml)
{
	struct ns1__RequiredFilesResponse *soap_tmp_ns1__RequiredFilesResponse;
	soap_default_std__string(soap, &RequiredFilesXml);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__RequiredFilesResponse = soap_get_ns1__RequiredFilesResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__RequiredFilesResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	RequiredFilesXml = soap_tmp_ns1__RequiredFilesResponse->RequiredFilesXml;
	return soap_closesock(soap);
}

int xmdsBindingProxy::send_GetFile(const char *soap_endpoint_url, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, int fileId, const std::string& fileType, double chunkOffset, double chuckSize)
{
	struct ns1__GetFile soap_tmp_ns1__GetFile;
	if (soap_endpoint_url != NULL)
		soap_endpoint = soap_endpoint_url;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#GetFile";
	soap_tmp_ns1__GetFile.serverKey = serverKey;
	soap_tmp_ns1__GetFile.hardwareKey = hardwareKey;
	soap_tmp_ns1__GetFile.fileId = fileId;
	soap_tmp_ns1__GetFile.fileType = fileType;
	soap_tmp_ns1__GetFile.chunkOffset = chunkOffset;
	soap_tmp_ns1__GetFile.chuckSize = chuckSize;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/"; /* use SOAP encoding style */
	soap_serializeheader(soap);
	soap_serialize_ns1__GetFile(soap, &soap_tmp_ns1__GetFile);
	if (soap_begin_count(soap))
		return soap->error;
	if ((soap->mode & SOAP_IO_LENGTH))
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__GetFile(soap, &soap_tmp_ns1__GetFile, "ns1:GetFile", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__GetFile(soap, &soap_tmp_ns1__GetFile, "ns1:GetFile", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

int xmdsBindingProxy::recv_GetFile(xsd__base64Binary &file)
{
	struct ns1__GetFileResponse *soap_tmp_ns1__GetFileResponse;
	file.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__GetFileResponse = soap_get_ns1__GetFileResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__GetFileResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	file = soap_tmp_ns1__GetFileResponse->file;
	return soap_closesock(soap);
}

int xmdsBindingProxy::send_Schedule(const char *soap_endpoint_url, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey)
{
	struct ns1__Schedule soap_tmp_ns1__Schedule;
	if (soap_endpoint_url != NULL)
		soap_endpoint = soap_endpoint_url;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#Schedule";
	soap_tmp_ns1__Schedule.serverKey = serverKey;
	soap_tmp_ns1__Schedule.hardwareKey = hardwareKey;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/"; /* use SOAP encoding style */
	soap_serializeheader(soap);
	soap_serialize_ns1__Schedule(soap, &soap_tmp_ns1__Schedule);
	if (soap_begin_count(soap))
		return soap->error;
	if ((soap->mode & SOAP_IO_LENGTH))
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__Schedule(soap, &soap_tmp_ns1__Schedule, "ns1:Schedule", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__Schedule(soap, &soap_tmp_ns1__Schedule, "ns1:Schedule", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

int xmdsBindingProxy::recv_Schedule(std::string &ScheduleXml)
{
	struct ns1__ScheduleResponse *soap_tmp_ns1__ScheduleResponse;
	soap_default_std__string(soap, &ScheduleXml);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__ScheduleResponse = soap_get_ns1__ScheduleResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__ScheduleResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	ScheduleXml = soap_tmp_ns1__ScheduleResponse->ScheduleXml;
	return soap_closesock(soap);
}

int xmdsBindingProxy::send_BlackList(const char *soap_endpoint_url, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, int mediaId, const std::string& type, const std::string& reason)
{
	struct ns1__BlackList soap_tmp_ns1__BlackList;
	if (soap_endpoint_url != NULL)
		soap_endpoint = soap_endpoint_url;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#BlackList";
	soap_tmp_ns1__BlackList.serverKey = serverKey;
	soap_tmp_ns1__BlackList.hardwareKey = hardwareKey;
	soap_tmp_ns1__BlackList.mediaId = mediaId;
	soap_tmp_ns1__BlackList.type = type;
	soap_tmp_ns1__BlackList.reason = reason;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/"; /* use SOAP encoding style */
	soap_serializeheader(soap);
	soap_serialize_ns1__BlackList(soap, &soap_tmp_ns1__BlackList);
	if (soap_begin_count(soap))
		return soap->error;
	if ((soap->mode & SOAP_IO_LENGTH))
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__BlackList(soap, &soap_tmp_ns1__BlackList, "ns1:BlackList", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__BlackList(soap, &soap_tmp_ns1__BlackList, "ns1:BlackList", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

int xmdsBindingProxy::recv_BlackList(bool &success)
{
	struct ns1__BlackListResponse *soap_tmp_ns1__BlackListResponse;
	soap_default_bool(soap, &success);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__BlackListResponse = soap_get_ns1__BlackListResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__BlackListResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	success = soap_tmp_ns1__BlackListResponse->success;
	return soap_closesock(soap);
}

int xmdsBindingProxy::send_SubmitLog(const char *soap_endpoint_url, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, const std::string& logXml)
{
	struct ns1__SubmitLog soap_tmp_ns1__SubmitLog;
	if (soap_endpoint_url != NULL)
		soap_endpoint = soap_endpoint_url;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#SubmitLog";
	soap_tmp_ns1__SubmitLog.serverKey = serverKey;
	soap_tmp_ns1__SubmitLog.hardwareKey = hardwareKey;
	soap_tmp_ns1__SubmitLog.logXml = logXml;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/"; /* use SOAP encoding style */
	soap_serializeheader(soap);
	soap_serialize_ns1__SubmitLog(soap, &soap_tmp_ns1__SubmitLog);
	if (soap_begin_count(soap))
		return soap->error;
	if ((soap->mode & SOAP_IO_LENGTH))
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__SubmitLog(soap, &soap_tmp_ns1__SubmitLog, "ns1:SubmitLog", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__SubmitLog(soap, &soap_tmp_ns1__SubmitLog, "ns1:SubmitLog", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

int xmdsBindingProxy::recv_SubmitLog(bool &success)
{
	struct ns1__SubmitLogResponse *soap_tmp_ns1__SubmitLogResponse;
	soap_default_bool(soap, &success);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__SubmitLogResponse = soap_get_ns1__SubmitLogResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__SubmitLogResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	success = soap_tmp_ns1__SubmitLogResponse->success;
	return soap_closesock(soap);
}

int xmdsBindingProxy::send_SubmitStats(const char *soap_endpoint_url, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, const std::string& statXml)
{
	struct ns1__SubmitStats soap_tmp_ns1__SubmitStats;
	if (soap_endpoint_url != NULL)
		soap_endpoint = soap_endpoint_url;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#SubmitLog";
	soap_tmp_ns1__SubmitStats.serverKey = serverKey;
	soap_tmp_ns1__SubmitStats.hardwareKey = hardwareKey;
	soap_tmp_ns1__SubmitStats.statXml = statXml;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/"; /* use SOAP encoding style */
	soap_serializeheader(soap);
	soap_serialize_ns1__SubmitStats(soap, &soap_tmp_ns1__SubmitStats);
	if (soap_begin_count(soap))
		return soap->error;
	if ((soap->mode & SOAP_IO_LENGTH))
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__SubmitStats(soap, &soap_tmp_ns1__SubmitStats, "ns1:SubmitStats", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__SubmitStats(soap, &soap_tmp_ns1__SubmitStats, "ns1:SubmitStats", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

int xmdsBindingProxy::recv_SubmitStats(bool &success)
{
	struct ns1__SubmitStatsResponse *soap_tmp_ns1__SubmitStatsResponse;
	soap_default_bool(soap, &success);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__SubmitStatsResponse = soap_get_ns1__SubmitStatsResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__SubmitStatsResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	success = soap_tmp_ns1__SubmitStatsResponse->success;
	return soap_closesock(soap);
}

int xmdsBindingProxy::send_MediaInventory(const char *soap_endpoint_url, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, const std::string& mediaInventory)
{
	struct ns1__MediaInventory soap_tmp_ns1__MediaInventory;
	if (soap_endpoint_url != NULL)
		soap_endpoint = soap_endpoint_url;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#MediaInventory";
	soap_tmp_ns1__MediaInventory.serverKey = serverKey;
	soap_tmp_ns1__MediaInventory.hardwareKey = hardwareKey;
	soap_tmp_ns1__MediaInventory.mediaInventory = mediaInventory;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/"; /* use SOAP encoding style */
	soap_serializeheader(soap);
	soap_serialize_ns1__MediaInventory(soap, &soap_tmp_ns1__MediaInventory);
	if (soap_begin_count(soap))
		return soap->error;
	if ((soap->mode & SOAP_IO_LENGTH))
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__MediaInventory(soap, &soap_tmp_ns1__MediaInventory, "ns1:MediaInventory", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__MediaInventory(soap, &soap_tmp_ns1__MediaInventory, "ns1:MediaInventory", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

int xmdsBindingProxy::recv_MediaInventory(bool &success)
{
	struct ns1__MediaInventoryResponse *soap_tmp_ns1__MediaInventoryResponse;
	soap_default_bool(soap, &success);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__MediaInventoryResponse = soap_get_ns1__MediaInventoryResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__MediaInventoryResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	success = soap_tmp_ns1__MediaInventoryResponse->success;
	return soap_closesock(soap);
}

int xmdsBindingProxy::send_GetResource(const char *soap_endpoint_url, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, int layoutId, const std::string& regionId, const std::string& mediaId)
{
	struct ns1__GetResource soap_tmp_ns1__GetResource;
	if (soap_endpoint_url != NULL)
		soap_endpoint = soap_endpoint_url;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#GetResource";
	soap_tmp_ns1__GetResource.serverKey = serverKey;
	soap_tmp_ns1__GetResource.hardwareKey = hardwareKey;
	soap_tmp_ns1__GetResource.layoutId = layoutId;
	soap_tmp_ns1__GetResource.regionId = regionId;
	soap_tmp_ns1__GetResource.mediaId = mediaId;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/"; /* use SOAP encoding style */
	soap_serializeheader(soap);
	soap_serialize_ns1__GetResource(soap, &soap_tmp_ns1__GetResource);
	if (soap_begin_count(soap))
		return soap->error;
	if ((soap->mode & SOAP_IO_LENGTH))
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__GetResource(soap, &soap_tmp_ns1__GetResource, "ns1:GetResource", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__GetResource(soap, &soap_tmp_ns1__GetResource, "ns1:GetResource", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

int xmdsBindingProxy::recv_GetResource(std::string &resource)
{
	struct ns1__GetResourceResponse *soap_tmp_ns1__GetResourceResponse;
	soap_default_std__string(soap, &resource);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__GetResourceResponse = soap_get_ns1__GetResourceResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__GetResourceResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	resource = soap_tmp_ns1__GetResourceResponse->resource;
	return soap_closesock(soap);
}

int xmdsBindingProxy::send_NotifyStatus(const char *soap_endpoint_url, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, const std::string& status)
{
	struct ns1__NotifyStatus soap_tmp_ns1__NotifyStatus;
	if (soap_endpoint_url != NULL)
		soap_endpoint = soap_endpoint_url;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#NotifyStatus";
	soap_tmp_ns1__NotifyStatus.serverKey = serverKey;
	soap_tmp_ns1__NotifyStatus.hardwareKey = hardwareKey;
	soap_tmp_ns1__NotifyStatus.status = status;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/"; /* use SOAP encoding style */
	soap_serializeheader(soap);
	soap_serialize_ns1__NotifyStatus(soap, &soap_tmp_ns1__NotifyStatus);
	if (soap_begin_count(soap))
		return soap->error;
	if ((soap->mode & SOAP_IO_LENGTH))
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__NotifyStatus(soap, &soap_tmp_ns1__NotifyStatus, "ns1:NotifyStatus", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__NotifyStatus(soap, &soap_tmp_ns1__NotifyStatus, "ns1:NotifyStatus", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

int xmdsBindingProxy::recv_NotifyStatus(bool &success)
{
	struct ns1__NotifyStatusResponse *soap_tmp_ns1__NotifyStatusResponse;
	soap_default_bool(soap, &success);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__NotifyStatusResponse = soap_get_ns1__NotifyStatusResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__NotifyStatusResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	success = soap_tmp_ns1__NotifyStatusResponse->success;
	return soap_closesock(soap);
}

int xmdsBindingProxy::send_SubmitScreenShot(const char *soap_endpoint_url, const char *soap_action, const std::string& serverKey, const std::string& hardwareKey, const xsd__base64Binary& screenShot)
{
	struct ns1__SubmitScreenShot soap_tmp_ns1__SubmitScreenShot;
	if (soap_endpoint_url != NULL)
		soap_endpoint = soap_endpoint_url;
	if (soap_endpoint == NULL)
		soap_endpoint = "{{XMDS_LOCATION}}";
	if (soap_action == NULL)
		soap_action = "urn:xmds#SubmitScreenShot";
	soap_tmp_ns1__SubmitScreenShot.serverKey = serverKey;
	soap_tmp_ns1__SubmitScreenShot.hardwareKey = hardwareKey;
	soap_tmp_ns1__SubmitScreenShot.screenShot = screenShot;
	soap_begin(soap);
	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/"; /* use SOAP encoding style */
	soap_serializeheader(soap);
	soap_serialize_ns1__SubmitScreenShot(soap, &soap_tmp_ns1__SubmitScreenShot);
	if (soap_begin_count(soap))
		return soap->error;
	if ((soap->mode & SOAP_IO_LENGTH))
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns1__SubmitScreenShot(soap, &soap_tmp_ns1__SubmitScreenShot, "ns1:SubmitScreenShot", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns1__SubmitScreenShot(soap, &soap_tmp_ns1__SubmitScreenShot, "ns1:SubmitScreenShot", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	return SOAP_OK;
}

int xmdsBindingProxy::recv_SubmitScreenShot(bool &success)
{
	struct ns1__SubmitScreenShotResponse *soap_tmp_ns1__SubmitScreenShotResponse;
	soap_default_bool(soap, &success);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns1__SubmitScreenShotResponse = soap_get_ns1__SubmitScreenShotResponse(soap, NULL, "", NULL);
	if (!soap_tmp_ns1__SubmitScreenShotResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	success = soap_tmp_ns1__SubmitScreenShotResponse->success;
	return soap_closesock(soap);
}
/* End of client proxy code */
